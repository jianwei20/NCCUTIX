{
  "_args": [
    [
      {
        "raw": "redux-auth-wrapper@^1.0.0",
        "scope": null,
        "escapedName": "redux-auth-wrapper",
        "name": "redux-auth-wrapper",
        "rawSpec": "^1.0.0",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "/Users/sujianwei20/Desktop/bloxoffice"
    ]
  ],
  "_cnpm_publish_time": 1493186776749,
  "_from": "redux-auth-wrapper@^1.0.0",
  "_hasShrinkwrap": false,
  "_id": "redux-auth-wrapper@1.1.0",
  "_location": "/redux-auth-wrapper",
  "_nodeVersion": "6.8.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/redux-auth-wrapper-1.1.0.tgz_1493186775661_0.774941990384832"
  },
  "_npmUser": {
    "name": "mjrussell",
    "email": "matthewjosephrussell@gmail.com"
  },
  "_npmVersion": "3.10.8",
  "_phantomChildren": {
    "fbjs": "0.8.16"
  },
  "_requested": {
    "raw": "redux-auth-wrapper@^1.0.0",
    "scope": null,
    "escapedName": "redux-auth-wrapper",
    "name": "redux-auth-wrapper",
    "rawSpec": "^1.0.0",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "http://registry.npm.taobao.org/redux-auth-wrapper/download/redux-auth-wrapper-1.1.0.tgz",
  "_shasum": "ccd4a753fe2134eb93c44f4e5781054577f6244a",
  "_shrinkwrap": null,
  "_spec": "redux-auth-wrapper@^1.0.0",
  "_where": "/Users/sujianwei20/Desktop/bloxoffice",
  "authors": [
    "Matthew Russell"
  ],
  "bugs": {
    "url": "https://github.com/mjrussell/redux-auth-wrapper/issues"
  },
  "dependencies": {
    "hoist-non-react-statics": "1.2.0",
    "lodash.isempty": "4.4.0",
    "prop-types": "15.5.8"
  },
  "description": "A utility library for handling authentication and authorization for redux and react-router",
  "devDependencies": {
    "babel-cli": "6.18.0",
    "babel-core": "6.18.2",
    "babel-eslint": "6.1.2",
    "babel-istanbul": "0.11.0",
    "babel-loader": "6.2.7",
    "babel-plugin-transform-decorators-legacy": "1.3.4",
    "babel-polyfill": "6.16.0",
    "babel-preset-es2015": "6.18.0",
    "babel-preset-react": "6.16.0",
    "babel-preset-stage-0": "6.16.0",
    "chai": "3.5.0",
    "coveralls": "2.11.15",
    "enzyme": "2.6.0",
    "eslint": "1.7.1",
    "eslint-config-rackt": "1.1.1",
    "eslint-plugin-react": "3.16.0",
    "expect": "1.20.2",
    "jsdom": "9.8.3",
    "lodash": "4.16.6",
    "mocha": "3.1.2",
    "react": "15.3.2",
    "react-addons-test-utils": "15.3.2",
    "react-dom": "15.3.2",
    "react-redux": "4.4.5",
    "react-router": "3.0.0",
    "react-router-redux": "4.0.7",
    "redux": "3.6.0",
    "sinon": "1.17.6",
    "webpack": "1.13.3"
  },
  "directories": {},
  "dist": {
    "shasum": "ccd4a753fe2134eb93c44f4e5781054577f6244a",
    "size": 12419,
    "noattachment": false,
    "tarball": "http://registry.npm.taobao.org/redux-auth-wrapper/download/redux-auth-wrapper-1.1.0.tgz"
  },
  "files": [
    "*.md",
    "LICENSE",
    "lib",
    "src"
  ],
  "gitHead": "c0652c9bffd140cb45a10f536a0336694087728d",
  "homepage": "https://github.com/mjrussell/redux-auth-wrapper#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "mjrussell",
      "email": "matthewjosephrussell@gmail.com"
    }
  ],
  "name": "redux-auth-wrapper",
  "optionalDependencies": {},
  "publish_time": 1493186776749,
  "readme": "# redux-auth-wrapper\n\n[![npm](https://img.shields.io/npm/v/redux-auth-wrapper.svg)](https://www.npmjs.com/package/redux-auth-wrapper)\n[![npm dm](https://img.shields.io/npm/dm/redux-auth-wrapper.svg)](https://www.npmjs.com/package/redux-auth-wrapper)\n[![Build Status](https://travis-ci.org/mjrussell/redux-auth-wrapper.svg?branch=master)](https://travis-ci.org/mjrussell/redux-auth-wrapper)\n[![Coverage Status](https://coveralls.io/repos/github/mjrussell/redux-auth-wrapper/badge.svg?branch=master)](https://coveralls.io/github/mjrussell/redux-auth-wrapper?branch=master)\n[![Join the chat at https://gitter.im/mjrussell/redux-auth-wrapper](https://badges.gitter.im/mjrussell/redux-auth-wrapper.svg)](https://gitter.im/mjrussell/redux-auth-wrapper?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n**Decouple your Authentication and Authorization from your components!**\n\n`npm install --save redux-auth-wrapper`\n\n**Versioning Note:** This project adheres to [semver](http://semver.org/). Please view the [Changelog](/CHANGELOG.md) for release notes.\n\n## Contents\n* [Motivation](#motivation)\n* [Tutorial](#tutorial)\n* [API](#api)\n* [Authorization & Advanced Usage](#authorization--advanced-usage)\n* [Hiding and Alternate Components](#hiding-and-alternate-components)\n* [Where to define & apply the wrappers](#where-to-define--apply-the-wrappers)\n* [Protecting Multiple Routes](#protecting-multiple-routes)\n* [Dispatching an Additional Redux Action on Redirect](#dispatching-an-additional-redux-action-on-redirect)\n* [Server Side Rendering](#server-side-rendering)\n* [React Native](#react-native)\n* [Examples](#examples)\n\n## Motivation\n\nAt first, handling authentication and authorization seems easy in React-Router and Redux. After all, we have a handy [onEnter](https://github.com/rackt/react-router/blob/master/docs/API.md#onenternextstate-replace-callback) method, shouldn't we use it?\n\n`onEnter` is great, and useful in certain situations. However, here are some common authentication and authorization problems `onEnter` does not solve:\n* Decide authentication/authorization from redux store data (there are some [workarounds](https://github.com/CrocoDillon/universal-react-redux-boilerplate/blob/master/src/routes.js#L8))\n* Recheck authentication/authorization if the store updates (but not the current route)\n* Recheck authentication/authorization if a child route changes underneath the protected route (React Router 2.0 now supports this with `onChange`)\n\nAn alternative approach is to use [Higher Order Components](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.ao9jjxx89).\n> A higher-order component is just a function that takes an existing component and returns another component that wraps it\n\nRedux-auth-wrapper provides higher-order components for easy to read and apply authentication and authorization constraints for your components.\n\n## Tutorial\n\nUsage with [React-Router-Redux](https://github.com/rackt/react-router-redux) (Version 4.0)\n\n```js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { createStore, combineReducers, applyMiddleware, compose } from 'redux'\nimport { Provider } from 'react-redux'\nimport { Router, Route, browserHistory } from 'react-router'\nimport { routerReducer, syncHistoryWithStore, routerActions, routerMiddleware } from 'react-router-redux'\nimport { UserAuthWrapper } from 'redux-auth-wrapper'\nimport userReducer from '<project-path>/reducers/userReducer'\n\nconst reducer = combineReducers({\n  routing: routerReducer,\n  user: userReducer\n})\n\nconst routingMiddleware = routerMiddleware(browserHistory)\n\n// Note: passing middleware as the last argument requires redux@>=3.1.0\nconst store = createStore(\n  reducer,\n  applyMiddleware(routingMiddleware)\n)\nconst history = syncHistoryWithStore(browserHistory, store)\n\n// Redirects to /login by default\nconst UserIsAuthenticated = UserAuthWrapper({\n  authSelector: state => state.user, // how to get the user state\n  redirectAction: routerActions.replace, // the redux action to dispatch for redirect\n  wrapperDisplayName: 'UserIsAuthenticated' // a nice name for this auth check\n})\n\nReactDOM.render(\n  <Provider store={store}>\n    <Router history={history}>\n      <Route path=\"/\" component={App}>\n        <Route path=\"login\" component={Login}/>\n        <Route path=\"foo\" component={UserIsAuthenticated(Foo)}/>\n        <Route path=\"bar\" component={Bar}/>\n      </Route>\n    </Router>\n  </Provider>,\n  document.getElementById('mount')\n)\n```\n\nAnd your userReducer looks something like:\n```js\nconst userReducer = (state = {}, { type, payload }) => {\n  if (type === USER_LOGGED_IN) {\n    return payload\n  }\n  if (type === USER_LOGGED_OUT) {\n    return {}\n  }\n  return state\n}\n```\n\nWhen the user navigates to `/foo`, one of the following occurs:\n\n1. If The user data is null or an empty object:\n\n    The user is redirected to `/login?redirect=%2foo`\n\n    *Notice the url contains the query parameter `redirect` for sending the user back to after you log them into your app*\n2. Otherwise:\n\n    The `<Foo>` component is rendered and passed the user data as a property\n\nAny time the user data changes, the UserAuthWrapper will re-check for authentication.\n\n**Note:** You still need to provide a mechanism for redirecting the user from the login page back to your component. You can\nalso do that with redux-auth-wrapper! See the [loading example](https://github.com/mjrussell/redux-auth-wrapper/blob/master/examples/loading/app.js) for further details.\n\n## API\n\n`UserAuthWrapper(configObject)(DecoratedComponent)`\n\n#### Config Object Keys\n\n* `authSelector(state, [ownProps]): authData` \\(*Function*): A state selector for the auth data. Just like `mapToStateProps`.\nownProps will be null if isOnEnter is true because onEnter hooks cannot receive the component properties. Can be ignored when not using onEnter.\n* `authenticatingSelector(state, [ownProps]): Bool` \\(*Function*): A state selector indicating if the user is currently authenticating. Just like `mapToStateProps`. Useful for async session loading.\n* `LoadingComponent` \\(*Component*): A React component to render while `authenticatingSelector` is `true`. Will be passed\nall properties passed into the wrapped component, including `children`.\n* `FailureComponent` \\(*Component*): A React component to render when `authenticatingSelector` is `false`. If specified, the wrapper will\n**not** redirect. Can be set to `null` to display nothing when the user is not authenticated/authorized.\n* `[failureRedirectPath]` \\(*String | (state, [ownProps]): String*): Optional path to redirect the browser to on a failed check. Defaults to `/login`. Can also be a function of state and ownProps that returns a string.\n* `[redirectQueryParamName]` \\(*String*): Optional name of the query parameter added when `allowRedirectBack` is true. Defaults to `redirect`.\n* `[redirectAction]` \\(*Function*): Optional redux action creator for redirecting the user. If not present, will use React-Router's router context to perform the transition.\n* `[wrapperDisplayName]` \\(*String*): Optional name describing this authentication or authorization check.\nIt will display in React-devtools. Defaults to `UserAuthWrapper`\n* `[predicate(authData): Bool]` \\(*Function*): Optional function to be passed the result of the `authSelector` param.\nIf it evaluates to false the browser will be redirected to `failureRedirectPath`, otherwise `DecoratedComponent` will be rendered. By default, it returns false if `authData` is {} or null.\n* `[allowRedirectBack]` \\(*Bool | (location, redirectPath): Bool* ): Optional bool on whether to pass a `redirect` query parameter to the `failureRedirectPath`. Can also be a function of location and the computed `failureRedirectPath` passed above, that must return a boolean value. Defaults to `true`.\n* `[propMapper]` \\(*Function*): Optional function that takes the props passed into the wrapped component and returns those props to pass to the DecoratedComponent, The LoadingComponent, and the FailureComponent.\n\n#### Returns\nAfter applying the configObject, `UserAuthWrapper` returns a function which can applied to a Component to wrap in authentication and\nauthorization checks. The function also has the following extra properties:\n* `onEnter(store, nextState, replace)` \\(*Function*): Function to be optionally used in the [onEnter](https://github.com/reactjs/react-router/blob/master/docs/API.md#onenternextstate-replace-callback) property of a route.\n\n#### Component Parameter\n* `DecoratedComponent` \\(*React Component*): The component to be wrapped in the auth check. It will pass down all props given to the returned component as well as the prop `authData` which is the result of the `authSelector`.\nThe component is not modified and all static properties are hoisted to the returned component\n\n## Authorization & Advanced Usage\n\n```js\n/* Allow only users with first name Bob */\nconst OnlyBob = UserAuthWrapper({\n  authSelector: state => state.user,\n  redirectAction: routerActions.replace,\n  failureRedirectPath: '/app',\n  wrapperDisplayName: 'UserIsOnlyBob',\n  predicate: user => user.firstName === 'Bob'\n})\n\n/* Admins only */\n\n// Take the regular authentication & redirect to login from before\nconst UserIsAuthenticated = UserAuthWrapper({\n  authSelector: state => state.user,\n  redirectAction: routerActions.replace,\n  wrapperDisplayName: 'UserIsAuthenticated'\n})\n// Admin Authorization, redirects non-admins to /app and don't send a redirect param\nconst UserIsAdmin = UserAuthWrapper({\n  authSelector: state => state.user,\n  redirectAction: routerActions.replace,\n  failureRedirectPath: '/app',\n  wrapperDisplayName: 'UserIsAdmin',\n  predicate: user => user.isAdmin,\n  allowRedirectBack: false\n})\n\n// Now to secure the component: first check if the user is authenticated, and then check if the user is an admin\n<Route path=\"foo\" component={UserIsAuthenticated(UserIsAdmin(Admin))}/>\n```\n\nThe ordering of the nested higher order components is important because `UserIsAuthenticated(UserIsAdmin(Admin))`\nmeans that logged out admins will be redirected to `/login` before checking if they are an admin.\n\nOtherwise admins would be sent to `/app` if they weren't logged in and then redirected to `/login`, only to find themselves at `/app`\nafter entering their credentials.\n\n## Hiding and Alternate Components\n\n#### Hiding Components\n\nThe auth wrappers can be used for more than redirection. You can use the `FailureComponent` parameter to hide a\ncomponent or display an alternative component when the user is not authorized. Keep in mind that wrappers that use\n`FailureComponent` will not redirect users.\n\nHere is an example that hides a link from a non-admin user.\n```js\nconst VisibleOnlyAdmin = UserAuthWrapper({\n  authSelector: state => state.user,\n  wrapperDisplayName: 'VisibleOnlyAdmin',\n  predicate: user => user.isAdmin,\n  FailureComponent: null\n})\n\n// Applying to a function component for simplicity but could be Class or createClass component\nconst AdminOnlyLink = VisibleOnlyAdmin(() => <Link to='/admin'>Admin Section</Link>)\n```\n\nYou can see an example of hiding links in the basic example.\n\n#### Alternate Components\n\nAlternatively, you can specify a FailureComponent to display an alternative component, in this example we specify a new\nfunction for our returned HOC to make it more flexible to apply across the app.\n\n```js\nconst AdminOrElse = (Component, FailureComponent) => UserAuthWrapper({\n  authSelector: state => state.user,\n  wrapperDisplayName: 'AdminOrElse',\n  predicate: user => user.isAdmin,\n  FailureComponent\n})(Component)\n\n// Show Admin dashboard to admins and user dashboard to regular users\n<Route path='/dashboard' component={AdminOrElse(AdminDashboard, UserDashboard)} />\n```\n\n## Where to define & apply the wrappers\n\nOne benefit of the beginning example is that it is clear from looking at the Routes where the\nauthentication & authorization logic is applied. There are a variety of other places to apply redux-auth-wrapper. Please\nreview this section first to avoid incorrectly applying the HOC and causing bugs in your code.\n\n#### Safe to Apply\n\nDirectly inside ReactDOM.render:\n```js\nReactDOM.render(\n  <Provider store={store}>\n    <Router history={history}>\n      <Route path=\"/\" component={App}>\n        <Route path=\"auth\" component={UserIsAuthenticated(Foo)}/>\n        ...\n      </Route>\n    </Router>\n  </Provider>,\n  document.getElementById('mount')\n)\n```\n\nSeparate route config file:\n```js\nconst routes = (\n  <Route path=\"/\" component={App}>\n    <Route path=\"auth\" component={UserIsAuthenticated(Foo)}/>\n    ...\n  </Route>\n)\n\nReactDOM.render(  \n  <Provider store={store}>\n    <Router history={history}>\n      {routes}\n    </Router>\n  </Provider>,\n  document.getElementById('mount')\n)\n```\n\nApplied in the component file (es7):\n```js\n@UserIsAuthenticated\nexport default class MyComponent extends Component {\n  ...\n}\n```\n\nApplied in the component file (es6):\n```js\nclass MyComponent extends Component {\n  ...\n}\nexport default UserIsAuthenticated(MyComponent)\n```\n\nApplied outside the component file:\n```js\nimport MyComponent from './component/mycomponent.js'\n\nconst MyAuthComponent = UserIsAuthenticated(MyComponent)\n```\n\n#### Not Safe to Apply\n\nThe following are all not safe because they create a new component over and over again, preventing react from considering these the \"same\" component and causing mounting/unmounting loops.\n\nInside of render:\n```js\nimport MyComponent from './component/MyComponent.js'\n\nclass MyParentComponent extends Component {\n  render() {\n    const MyAuthComponent = UserIsAuthenticated(MyComponent)\n    return <MyAuthComponent />\n  }\n}\n```\n\nInside of any `getComponent`:\n```js\nconst routes = (\n  <Route path=\"/\" component={App}>\n    <Route path=\"auth\" getComponent={(nextState, cb) => {\n      cb(null, UserIsAuthenticated(Foo))\n     }} />\n     ...\n  </Route>\n)\n```\n\n## Protecting Multiple Routes\nBecause routes in React Router are not required to have paths, you can use nesting to protect multiple routes without applying\nthe wrapper multiple times.\n```js\nconst Authenticated = UserIsAuthenticated((props) => React.cloneElement(props.children, props));\n\n<Route path='/' component={App}>\n   <IndexRedirect to=\"/login\" />\n   <Route path='login' component={Login} />\n   <Route component={Authenticated}>\n     <Route path=\"foo\" component={Foo} />\n     <Route path=\"bar\" component={Bar} />\n   </Route>\n</Route>\n```\n\n## Dispatching an Additional Redux Action on Redirect\nYou may want to dispatch an additional redux action when a redirect occurs. One example of this is to display a notification message\nthat the user is being redirected or don't have access to that protected resource. To do this, you can chain the `redirectAction`\nparameter using `redux-thunk` middleware. It depends slightly on if you are using a redux + routing solution or just React Router.\n\n#### Using `react-router-redux` or `redux-router` and dispatching an extra redux action in the wrapper\n```js\nimport { replace } from 'react-router-redux'; // Or your redux-router equivalent\nimport addNotification from './notificationActions';\n\n// Admin Authorization, redirects non-admins to /app\nconst UserIsAdmin = UserAuthWrapper({\n  failureRedirectPath: '/app',\n  predicate: user => user.isAdmin,\n  redirectAction: (newLoc) => (dispatch) => {\n     dispatch(replace(newLoc));\n     dispatch(addNotification({ message: 'Sorry, you are not an administrator' }));\n  },\n  ...\n})\n```\n\n#### Using React Router with history singleton and extra redux action\n```js\nimport { browserHistory } from 'react-router';\nimport addNotification from './notificationActions';\n\n// Admin Authorization, redirects non-admins to /app\nconst UserIsAdmin = UserAuthWrapper({\n  failureRedirectPath: '/app',\n  predicate: user => user.isAdmin,\n  redirectAction: (newLoc) => (dispatch) => {\n     browserHistory.replace(newLoc);\n     dispatch(addNotification({ message: 'Sorry, you are not an administrator' }));\n  },\n  ...\n})\n```\n\n\n## Server Side Rendering\nIf your `UserAuthWrapper` uses redirection, then you may need to use the `onEnter` property\nof a `<Route>` to perform authentication and authorization checks for Server Side Rendering. (Note: If you are only using `FailureComponent` and not redirecting in your `UserAuthWrapper`, then you do not need to use `onEnter` option described below.)\n\nDuring onEnter, selectors such as `authSelector`, `authenticatingSelector`, and `failureRedirectPath` (if you are using)\nthe function variation, will receive react-router's `nextState` as their second argument instead of the component props.\n\nYou can access the `onEnter` method of the `UserAuthWrapper` after applying the config parameters:\n```js\nimport { UserAuthWrapper } from 'redux-auth-wrapper';\n\nconst UserIsAuthenticated = UserAuthWrapper({\n  authSelector: state => state.user,\n  redirectAction: routerActions.replace,\n  wrapperDisplayName: 'UserIsAuthenticated'\n})\n\nconst getRoutes = (store) => {\n  const connect = (fn) => (nextState, replaceState) => fn(store, nextState, replaceState);\n\n  return (\n    <Route>\n      <Route path=\"/\" component={App}>\n        <Route path=\"login\" component={Login}/>\n        <Route path=\"foo\" component={UserIsAuthenticated(Foo)} onEnter={connect(UserIsAuthenticated.onEnter)} />\n      </Route>\n    </Route>\n  );\n};\n```\n\n#### Server Side Rendering (SSR) with nested auth wrappers\nTo implement SSR with nested wrappers, you will have to provide a function to chain `onEnter` functions of each wrapper. To illustrate this, we can modify the example provided in the [Authorization & Advanced Usage](#authorization--advanced-usage) section above, wherein `UserIsAuthenticated` is the parent wrapper and `UserIsAdmin` is the child wrapper.\n\n```js\nimport { UserAuthWrapper } from 'redux-auth-wrapper';\n\nconst UserIsAuthenticated = UserAuthWrapper({\n  authSelector: state => state.user,\n  redirectAction: routerActions.replace,\n  wrapperDisplayName: 'UserIsAuthenticated'\n})\n\n// Admin Authorization, redirects non-admins to /app and don't send a redirect param\nconst UserIsAdmin = UserAuthWrapper({\n  authSelector: state => state.user,\n  redirectAction: routerActions.replace,\n  failureRedirectPath: '/app',\n  wrapperDisplayName: 'UserIsAdmin',\n  predicate: user => user.isAdmin,\n  allowRedirectBack: false\n})\n\nconst getRoutes = (store) => {\n  const connect = (fn) => (nextState, replaceState) => fn(store, nextState, replaceState);\n\n  //This executes the parent onEnter first, going from left to right.\n  // `replace` has to be wrapped because we want to stop executing `onEnter` hooks\n  // after the first call to `replace`.\n  const onEnterChain = (...listOfOnEnters) => (store, nextState, replace) => {\n    let redirected = false;\n    const wrappedReplace = (...args) => {\n      replace(...args);\n      redirected = true;\n    };\n    listOfOnEnters.forEach((onEnter) => {\n      if (!redirected) {\n        onEnter(store, nextState, wrappedReplace);\n      }\n    });\n  };\n\n  return (\n    <Route>\n      <Route path=\"/\" component={App}>\n        <Route path=\"login\" component={Login}/>\n        <Route path=\"foo\"\n          component={UserIsAuthenticated(UserIsAdmin(Admin))}\n          onEnter={connect(onEnterChain(UserIsAuthenticated.onEnter, UserIsAdmin.onEnter))} />\n      </Route>\n    </Route>\n  );\n};\n\n```\n\n## React Native\n\nThis library can be used with React Native `>= 0.25.0` without any changes.\n\nUsing React Native and redux-auth-wrapper? Please help create an example for others to get started!\n\n## Examples\n* [Basic Example](https://github.com/mjrussell/redux-auth-wrapper/tree/master/examples/basic)\n* [Loading Component Example](https://github.com/mjrussell/redux-auth-wrapper/tree/master/examples/loading)\n* [Local Storage Example](https://github.com/mjrussell/redux-auth-wrapper/tree/master/examples/localStorage)\n* [Redux-Router and React-Router 1.0 with JWT](https://github.com/mjrussell/react-redux-jwt-auth-example/tree/auth-wrapper)\n* [React-Router-Redux and React-Router 2.0 with JWT](https://github.com/mjrussell/react-redux-jwt-auth-example/tree/react-router-redux)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mjrussell/redux-auth-wrapper.git"
  },
  "scripts": {
    "build": "mkdir -p lib && babel ./src --out-dir ./lib",
    "lint": "eslint src test",
    "prepublish": "rm -rf lib && npm run build",
    "test": "mocha --compilers js:babel-core/register --recursive --require test/init.js test/**/*-test.js",
    "test:cov": "babel-node --max-old-space-size=4076 $(npm bin)/babel-istanbul cover $(npm bin)/_mocha -- --require test/init.js test/**/*-test.js",
    "test:watch": "mocha --compilers js:babel-core/register --recursive --require test/init.js -w test/**/*-test.js"
  },
  "version": "1.1.0"
}
